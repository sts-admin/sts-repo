{"version":3,"sources":["ui-listView.js","templates.js","ui-listViewAnchor.js","ui-listViewCell.js"],"names":[],"mappings":"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","file":"ui-listView.js","sourcesContent":["/**\n * @ngdoc module\n * @name ui-listView\n * @description\n * Displays a list of items.  Designed to handle large data sets.\n */\nvar module = angular.module(\"ui-listView\", [\n    \"ui-listView.templates\"\n]);\n\nvar arrayRegexp = /^\\s*([a-zA-Z0-9]+)\\s+(?:in)\\s+([a-zA-Z0-9.]+(\\s*[|].*$)?)/; // \"item in array [|filterName]\"\nvar defaultOptions = {\n    preferredHeight: 48\n};\n\n/**\n * Run digest only if it is not currently running.\n */\nfunction safeDigest ($scope) {\n    if (!$scope.$root.$$phase) {\n        $scope.$digest();\n    }\n}\n\n/**\n * @ngdoc controller\n * @memberOf ui-listView\n * @description\n * Displays a list of items.  Designed to handle large data sets.  The list view's controller\n * is added to the options object to provide an API.\n * @class\n */\nclass UIListView {\n    \n    constructor () {\n        this.cells = [];\n        this.setOptions({});\n    }\n    \n    /**\n     * Set new options for the list view.\n     * @param {ui-listView.UIListView.Options} options\n     * @method\n     */\n    setOptions (options) {\n        this._addDefaultOptions(options);\n        options.listView = this;\n        this.options = options;\n        this.reload([]);\n    }\n    \n    /**\n      * Reload the list view from scratch.  The rows will be\n      * computed.\n      * @param {Object[]} [items] Optionally change the list view's items;\n      * @method\n      */\n    reload (items) {\n        if ((items && items !== this.originalItems) || !this.originalItems) {\n            this._clear();\n            this.originalItems = items;\n        } else {\n            items = this.originalItems;\n        }\n        if (this.rows.length > items.length) {\n            this.rows.length = items.length;\n        }\n        this._rebuildRows(items);\n    }\n    \n    /**\n      * Request that the row offsets be recomputed. It will perform the update\n      * after the current digest.  This is useful if the offsets might be updated\n      * multiple times during a single digest.\n      * @param {Number} [startIndex] The index to start recomputing from.\n      * @method\n      */\n    requestOffsetUpdate (startIndex) {\n        var request = this._request;\n        if (!request) {\n            this._request = request = {\n                startIndex: startIndex\n            };\n            this._callDelegate(\"throttle\", () => {\n                this.updateRowOffsets(request.startIndex);\n                this._request = null;\n            });\n        }\n        request.startIndex = Math.min(request.startIndex, startIndex);\n    }\n    \n    /**\n      * Recompute the row offsets.\n      * @param {Number} [startIndex] The index to start recomputing from.\n      * @method\n      */\n    updateRowOffsets (startIndex) {\n        startIndex = startIndex || 0;\n        var rows = this.rows;\n        var row;\n        var currentOffset = rows[startIndex].offset;\n        var i;\n        \n        for (i = startIndex; i < rows.length; i++) {\n            row = rows[i];\n            row.offset = currentOffset;\n            if (row.cell) {\n                this._callCellDelegate(row.cell, \"offsetDidChange\", row.offset);\n            }\n            currentOffset += row.height;\n        }\n        this.layout();\n    }\n    \n    /**\n      * Updates the cells when the visible range changes.\n      * @method\n      */\n    updateCells () {\n        var range = this.visibleRange;\n        var offset = range.index;\n        var lastIndex = offset + range.length;\n        var rows = this.rows;\n        var cells = this.cells;\n        var cell, row, previousRow;\n        \n        // Always start with an odd value for CSS.\n        if (offset > 1 && (offset % 2)) {\n            offset--;\n        }\n        \n        cells.length = range.length;\n        for(var i = offset; i < lastIndex; i++) {\n            cell = cells[i - offset];\n            row = rows[i];\n            if (!cell) {\n                cell = cells[i - offset] = {};\n            }\n            if (cell.row) {\n                cell.row.cell = null;\n            }\n            row.cell = cell;\n            cell.row = row;\n            cell.item = rows[i].item;\n            cell.index = i;\n            cell.itemIdentifier = this._callDelegate(\"getItemIdentifier\", cell.item);\n            if (previousRow) {\n                row.offset = previousRow.offset + previousRow.height;\n            }\n            this._callCellDelegate(cell, \"rowDidChange\", row);\n            previousRow = row;\n        }\n    }\n    \n    /**\n      * Updates the anchor position when the viewport is changes.\n      * @method\n      */\n    updateAnchor () {\n        var scrollHeight = this.getScrollHeight();\n        var lastScrollHeight = this._lastScrollHeight;\n        if (this.anchor) {\n            this.anchor.updateAnchor(scrollHeight);\n            this._lastScrollHeight = scrollHeight;\n        }\n        return scrollHeight !== lastScrollHeight;\n    }\n    \n    /**\n      * Updates the visible range when the viewport changes.\n      * @return {Boolean} True if the range is changed.\n      * @method\n      */\n    updateRange () {\n        var viewport = this.viewport;\n        var topOffset = viewport.offset;\n        var bottomOffset = topOffset + viewport.height;\n        \n        var rows = this.rows;\n        var row;\n        \n        var mid = this._findVisibleRowIndex(topOffset, bottomOffset);\n        var foundFirst, foundLast;\n        var firstIndex = 0, lastIndex = 0;\n        var offset = 0;\n        \n        var range = this.visibleRange;\n        \n        while(!foundFirst || !foundLast) {\n            if (!foundFirst) {\n                row = rows[mid - offset];\n                if (!row || row.offset + row.height < topOffset) {\n                    foundFirst = true;\n                    firstIndex = Math.max(mid - offset, 0);\n                }\n            }\n            if (!foundLast) {\n                row = rows[mid + offset];\n                if (!row || row.offset > bottomOffset) {\n                    foundLast = true;\n                    lastIndex = Math.min(mid + offset, rows.length);\n                }\n            }\n            offset++;\n        }\n        \n        this.options.range = this.visibleRange = {\n            index: firstIndex,\n            length: lastIndex - firstIndex,\n            total: rows.length\n        };\n        return range.index !== this.visibleRange.index || range.length !== this.visibleRange.length;\n    }\n    \n    /**\n      * Set a new viewport.  This will relayout the list to that viewport.  This should not be called\n      * manually.\n      * @return {Boolean} True if the range is changed.\n      * @method\n      */\n    setViewport (offset, height) {\n        this.viewport = {\n            offset: offset,\n            height: height\n        };\n        return this.layout();\n    }\n    \n    /**\n      * Relayout the list view.  This is normally called when the viewport is updated.\n      * @return {Boolean} True if the range is changed.\n      * @method\n      */\n    layout () {\n        this.updateAnchor();\n        if (this.updateRange()) {\n            this.updateCells();\n            return true;\n        }\n        return false;\n    }\n    \n    /**\n      * The total scroll height of the list view.\n      * @return {Number}\n      * @method\n      */\n    getScrollHeight () {\n        var len = this.rows.length;\n        var lastRow = this.rows[len - 1];\n        return len ? lastRow.offset + lastRow.height : 0;\n    }\n    \n    /**\n      * Retrieve the styles for a cell.  This is used to set values like the cell's\n      * current \"top\" position.\n      * @param {sl.ui-listView.Cell} cell\n      * @method\n      */\n    getCellStyle (cell) {\n        return {\n            top: cell.row.offset + \"px\"\n        };\n    }\n    \n    /**\n     * Apply the default options when new ones are set.\n     * @param {ui-listView.UIListView.Options} options\n     * @private\n     */\n    _addDefaultOptions (options) {\n        for (var key in defaultOptions) {\n            if (!options.hasOwnProperty(key) && defaultOptions.hasOwnProperty(key)) {\n                options[key] = defaultOptions[key];\n            }\n        }\n    }\n    \n    /**\n      * Clears out and resets the list view's data.\n      * @param {Boolean} [removeRows] Also remove the row meta data objects;\n      * @method\n      * @private\n      */\n    _clear (removeRows) {\n        this.originalItems = [];\n        if (!this.rows || removeRows) {\n            this.rows = [];\n        }\n        this.cells = [];\n        this.options.range = this.visibleRange = {\n            index: 0,\n            length: 0\n        };\n    }\n    \n    /**\n      * Rebuilds all the rows with the given items.\n      * @param {Object[]} items\n      * @method\n      * @private\n      */\n    _rebuildRows (items) {\n        var offset = 0;\n        var rows = this.rows;\n        var row;\n        \n        for (var i = 0; i < items.length; i++) {\n            row = rows[i];\n            if (!row) {\n                row = rows[i] = {\n                    height: this.options.preferredHeight,\n                    offset: offset\n                };\n            } \n            row.index = i;\n            row.item = items[i];\n            row.cell = null;\n            offset += row.height;\n        }\n    }\n    \n    /**\n      * Tries to efficiently find a visible row within the given offset range.  It returns the\n      * index of the first row found.\n      * @param {Number} topOffset\n      * @param {Number} bottomOffset\n      * @method\n      * @private\n      */\n    _findVisibleRowIndex (topOffset, bottomOffset) {\n        var range = this.visibleRange;\n        var rows = this.rows;\n        var row;\n        var mid = Math.floor(range.index + (range.length / 2));\n        var start = 0, end = rows.length;\n        \n        if (mid > rows.length - 1) {\n            mid = Math.max(rows.length - 1, 0);\n        }\n        \n        while (end >= start && rows[mid]) {\n            row = rows[mid];\n            if (row.offset + row.height < topOffset) {\n                start = mid + 1;\n            } else if (row.offset > bottomOffset) {\n                end = mid - 1;\n            } else {\n                break; // first visible row found.\n            }\n            mid = start + Math.round((end - start) / 2);\n        }\n        \n        return mid;\n    }\n    \n    _callDelegate (methodName, arg1, arg2, arg3) {\n        var delegate = this.delegate;\n        if (delegate) {\n            return delegate[methodName](arg1, arg2, arg3);\n        }\n    }\n    \n    /**\n      * Call a method on the cell's delegate.\n      * @param {sl.ui-listView.Cell} cell\n      * @param {String} methodName\n      * @param {Object} arg1\n      * @param {Object} arg2\n      * @param {Object} arg3\n      * @method\n      * @private\n      */\n    _callCellDelegate (cell, methodName, arg1, arg2, arg3) {\n        var delegate = cell.delegate;\n        if (delegate) {\n            return delegate[methodName](arg1, arg2, arg3);\n        }\n    }\n    \n}\n\nmodule.controller(\"UIListView\", UIListView);\nmodule.directive(\"uiListView\", ($rootScope, $parse) => {\n    \n    /**\n     * @ngdoc directive\n     * @name ui-listView\n     * @description\n     * Displays a list of items.  Designed to handle large data sets.\n     */\n    return {\n        templateUrl: \"ui-listView.tpl.html\",\n        replace: true, // TODO: remove\n        transclude: true,\n        scope: { options: \"=\" },\n        \n        controller: \"UIListView\",\n        controllerAs: \"listView\",\n        \n        require: \"uiListView\",\n        compile (element, attrs) {\n            var match = arrayRegexp.exec(attrs.uiListView);\n            if (!match) {\n                throw Error(\"Invalid expression.  It must be in the form \\\"item in Array\\\" \"); \n            }\n            var itemIdentifier = match[1];\n            var arrayGetter = $parse(match[2]);\n            \n            return function ($scope, element, attrs, listView) {\n                var rawElement = element[0];\n                \n                listView.delegate = {\n                    \n                    getItemIdentifier () {\n                        return itemIdentifier;\n                    },\n                    \n                    throttle (fn) {\n                        $scope.$$postDigest(fn);\n                        safeDigest($scope);\n                    }\n                    \n                };\n                \n                /**\n                 * Update the viewport.\n                 */\n                function updateListView () {\n                    return listView.setViewport(rawElement.scrollTop, rawElement.clientHeight);\n                }\n                \n                $scope.$watch(\"options\", (options) => {\n                    listView.setOptions(options || {});\n                });\n                \n                var isScrolling; // For performance, don't retrieve items while the list is scrolling.\n                var endScrollDigestTimer;\n                $scope.$watchCollection(() => {\n                    return !isScrolling ? arrayGetter($scope.$parent) : listView.originalItems;\n                }, (items) => {\n                    listView.reload(items);\n                    updateListView();\n                });\n                \n                /**\n                 * Update the list when its size changes.\n                 */\n                $scope.$watch(() => {\n                    return rawElement.clientHeight + \"-\" + rawElement.clientWidth;\n                }, () => {\n                    updateListView();\n                });\n                \n                function handleScroll () {\n                    if (updateListView()) {\n                        isScrolling = true;\n                        safeDigest($scope);\n                        isScrolling = false;\n                    }\n                    clearTimeout(endScrollDigestTimer);\n                    endScrollDigestTimer = setTimeout(() => {\n                        updateListView();\n                        safeDigest($scope);\n                    });\n                }\n                \n                rawElement.addEventListener(\"scroll\", handleScroll, false);\n                \n                /** \n                * Digest the scope when the window resizes.\n                */\n                function handleResize () {\n                    safeDigest($scope);\n                }\n                window.addEventListener(\"resize\", handleResize);\n                \n                $scope.$on(\"$destroy\", () => {\n                    window.removeEventListener(\"resize\", handleResize);\n                });\n            };\n        }\n    };\n    \n});\n","angular.module(\"ui-listView.templates\", []).run([\"$templateCache\", function($templateCache) {$templateCache.put(\"ui-listView.tpl.html\",\"<div class=\\\"ui-list-view\\\">\\n    <div class=\\\"ui-list-view-cell\\\" ui-list-view-cell ng-repeat=\\\"cell in listView.cells\\\">\\n        <div class=\\\"ui-list-view-cell-content\\\"></div>\\n    </div>\\n    <div class=\\\"ui-list-view-anchor\\\" ui-list-view-anchor></div>\\n</div>\");}]);","/**\n * @ngdoc directive\n * @name uiListViewAnchor\n * @description\n * The anchor is used to set the list view's scroll height based on the last row's offset and height.\n * \n * @private\n */\nangular.module(\"ui-listView\").directive(\"uiListViewAnchor\", () => {\n    \n    return {\n        require: \"^uiListView\",\n        link ($scope, element, attr, listView) {\n            var rawElement = element[0];\n            \n            listView.anchor = {\n                updateAnchor (scrollHeight) {\n                    rawElement.style.top = scrollHeight + \"px\";\n                }\n            };\n            \n        }\n    };\n    \n});\n","/**\n * @ngdoc directive\n * @name uiListViewCell\n * @description\n * The visual representation of a list view cell.  A cell is a container\n * to a visible row.  As the list is scrolled, the cells are updated with the\n * current set of visible rows to display.\n * \n * Certain choices were made for performance reasons.  For example, instead of\n * watchers, the directive acts as a delegate to the cell.  When the cell is updated, it\n * delegates those changes to the directive.\n * \n * @private\n */\nangular.module(\"ui-listView\").directive(\"uiListViewCell\", () => {\n    \n    return {\n        require: \"^uiListView\",\n        link ($scope, element, attrs, listView, $transclude) {\n            var rawElement = element[0];\n            var cell = $scope.cell;\n            var transcludeScope;\n            \n            $transclude((clone, scope) => {\n                var content = element.children();\n                transcludeScope = scope;\n                updateRow(cell.row);\n                content.empty();\n                content.append(clone);\n            });\n            \n            function updateOffset(offset) {\n                rawElement.style.top = offset + \"px\";\n            }\n            \n            function updateSize() {\n                var height = rawElement.clientHeight;\n                var row = cell.row;\n                if (height !== row.height) {\n                    //listView.setRowHeight(row, height);\n                    row.height = height;\n                    listView.requestOffsetUpdate(row.index);\n                }\n            }\n            \n            function updateRow (row) {\n                transcludeScope[cell.itemIdentifier] = row.item;\n                transcludeScope.$index = row.index;\n                transcludeScope.$first = row.index === 0;\n                transcludeScope.$last = row.index === listView.rows.length - 1;\n                updateOffset(row.offset);\n            }\n            \n            $scope.$watch(() => {\n                return cell.row.index + \"-\" + rawElement.clientHeight;\n            }, () => {\n                updateSize();\n            });\n            \n            cell.delegate = {\n                rowDidChange: updateRow,\n                offsetDidChange: updateOffset\n            };\n                \n            updateRow(cell.row);\n        }\n    };\n    \n});\n"],"sourceRoot":"/source/"}